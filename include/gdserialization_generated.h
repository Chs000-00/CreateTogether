// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GDSERIALIZATION_CTSERIALIZE_H_
#define FLATBUFFERS_GENERATED_GDSERIALIZATION_CTSERIALIZE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "ccserialization_generated.h"

namespace CTSerialize {

struct GDGameObjectMin;
struct GDGameObjectMinBuilder;

struct GDGameObjectMin FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GDGameObjectMinBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNIQUEID = 4,
    VT_POS = 6,
    VT_ROTATION = 8,
    VT_ISHIGHDETAIL = 10,
    VT_NOGLOW = 12,
    VT_NOENTER = 14,
    VT_FLIP = 16
  };
  const ::flatbuffers::String *uniqueID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UNIQUEID);
  }
  const CTSerialize::CCPosI *pos() const {
    return GetStruct<const CTSerialize::CCPosI *>(VT_POS);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool isHighDetail() const {
    return GetField<uint8_t>(VT_ISHIGHDETAIL, 0) != 0;
  }
  bool noGlow() const {
    return GetField<uint8_t>(VT_NOGLOW, 0) != 0;
  }
  bool noEnter() const {
    return GetField<uint8_t>(VT_NOENTER, 0) != 0;
  }
  const CTSerialize::ObjectFlip *flip() const {
    return GetStruct<const CTSerialize::ObjectFlip *>(VT_FLIP);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UNIQUEID) &&
           verifier.VerifyString(uniqueID()) &&
           VerifyField<CTSerialize::CCPosI>(verifier, VT_POS, 4) &&
           VerifyField<float>(verifier, VT_ROTATION, 4) &&
           VerifyField<uint8_t>(verifier, VT_ISHIGHDETAIL, 1) &&
           VerifyField<uint8_t>(verifier, VT_NOGLOW, 1) &&
           VerifyField<uint8_t>(verifier, VT_NOENTER, 1) &&
           VerifyField<CTSerialize::ObjectFlip>(verifier, VT_FLIP, 1) &&
           verifier.EndTable();
  }
};

struct GDGameObjectMinBuilder {
  typedef GDGameObjectMin Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_uniqueID(::flatbuffers::Offset<::flatbuffers::String> uniqueID) {
    fbb_.AddOffset(GDGameObjectMin::VT_UNIQUEID, uniqueID);
  }
  void add_pos(const CTSerialize::CCPosI *pos) {
    fbb_.AddStruct(GDGameObjectMin::VT_POS, pos);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(GDGameObjectMin::VT_ROTATION, rotation, 0.0f);
  }
  void add_isHighDetail(bool isHighDetail) {
    fbb_.AddElement<uint8_t>(GDGameObjectMin::VT_ISHIGHDETAIL, static_cast<uint8_t>(isHighDetail), 0);
  }
  void add_noGlow(bool noGlow) {
    fbb_.AddElement<uint8_t>(GDGameObjectMin::VT_NOGLOW, static_cast<uint8_t>(noGlow), 0);
  }
  void add_noEnter(bool noEnter) {
    fbb_.AddElement<uint8_t>(GDGameObjectMin::VT_NOENTER, static_cast<uint8_t>(noEnter), 0);
  }
  void add_flip(const CTSerialize::ObjectFlip *flip) {
    fbb_.AddStruct(GDGameObjectMin::VT_FLIP, flip);
  }
  explicit GDGameObjectMinBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GDGameObjectMin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GDGameObjectMin>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GDGameObjectMin> CreateGDGameObjectMin(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> uniqueID = 0,
    const CTSerialize::CCPosI *pos = nullptr,
    float rotation = 0.0f,
    bool isHighDetail = false,
    bool noGlow = false,
    bool noEnter = false,
    const CTSerialize::ObjectFlip *flip = nullptr) {
  GDGameObjectMinBuilder builder_(_fbb);
  builder_.add_flip(flip);
  builder_.add_rotation(rotation);
  builder_.add_pos(pos);
  builder_.add_uniqueID(uniqueID);
  builder_.add_noEnter(noEnter);
  builder_.add_noGlow(noGlow);
  builder_.add_isHighDetail(isHighDetail);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GDGameObjectMin> CreateGDGameObjectMinDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *uniqueID = nullptr,
    const CTSerialize::CCPosI *pos = nullptr,
    float rotation = 0.0f,
    bool isHighDetail = false,
    bool noGlow = false,
    bool noEnter = false,
    const CTSerialize::ObjectFlip *flip = nullptr) {
  auto uniqueID__ = uniqueID ? _fbb.CreateString(uniqueID) : 0;
  return CTSerialize::CreateGDGameObjectMin(
      _fbb,
      uniqueID__,
      pos,
      rotation,
      isHighDetail,
      noGlow,
      noEnter,
      flip);
}

}  // namespace CTSerialize

#endif  // FLATBUFFERS_GENERATED_GDSERIALIZATION_CTSERIALIZE_H_
